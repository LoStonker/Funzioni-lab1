# -*- coding: utf-8 -*-
"""functions.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iT6HqQIJ2VPmgpDqhM9-Jg8-hVxutZmb
"""

import math
import numpy as np
from scipy.integrate import quad
from scipy.stats import chi2


def media(x): #MEDIA
    m = 0.0
    for i in x:
        m += i # += incrementa la variabile somma di i
    m /= len(x) # /= divide la variabile m per len(x)
    return m

def devst(x): #DEVIAZIONE STANDARD
  s = 0.0
  N = len(x)
  m = media(x)
  for i in x:
    s = s + (i-m)**2 #attenzione: potevo usare +=

  v = math.sqrt(s/(N-1))
  return v


def erroreStandardMedia(x): #ERRORE STANDARD DELLA MEDIA
  N = len(x)
  e = devst(x)/math.sqrt(N)
  return e



def minimi_quadrati1(x, y, s_y) :   #Minimi quadrati per interpolazione lineare Y = A + BX con sigma_y singola
  s = np.sum(y)*np.sum(x**2)-np.sum(x)*np.sum(x*y)
  s2 = len(x)*np.sum(x*y)-np.sum(x)*np.sum(y)
  d  = len(x)*np.sum(x**2)-(np.sum(x))**2
  A = s/d
  B = s2/d
  sigma_a = (np.sqrt(np.sum(x**2)/d))*s_y
  sigma_b = np.sqrt(len(x)/d)*s_y

  return A, B, sigma_a, sigma_b


def minimi_quadrati2(x, y, s_y) :   #Minimi quadrati per interpolazione lineare Y = A + BX con sigma_y diverse (array)
  f=np.sum(y)/np.sum(s_y**2)
  g=np.sum(x**2)/np.sum(s_y**2)
  h=np.sum(x)/np.sum(s_y**2)
  j=(np.sum(x*y))/np.sum(s_y**2)
  k=np.sum(1/s_y**2)
  l=h**2

  A= (f*g-h*j)/(k*g-l)
  B= (k*j-h*f)/(k*g-l)

  sigma_a = np.sqrt(np.absolute(g/(k*g-l)))
  sigma_b = np.sqrt(np.absolute(k/(k*g-l)))

  return A, B, sigma_a, sigma_b

def chi2(A,B, x, y, sy) :  #Chi quadro relativo all'interpolazione lineare
  s=np.sum(np.power(y-A-B*x,2)/sy**2)
  return s

def chi2prob(x, chi23) :
    s = chi2.pdf(chi23, len(x)-2)
    r = 100 - s*100
    return r
    

def chi2Gauss(E, O) :  #Chi quadro distribuzioni Gaussiane
  s = O - E
  q = np.sqrt(E)
  r = np.sum(np.power(s/q , 2))
  return r


def Gaussian(z):
  return (1/np.sqrt(2*np.pi))*np.exp((-z**2)/2) #Gaussiana standardizzata



def Test_hp(x1,x2,s1,s2) :
  t = np.absolute(x1-x2)/np.sqrt(s1**2+s2**2)  #t di confronto
  R = quad(Gaussian,-t,t) #calcolo del rapporto con l'integrale
  S = (1 - R[0])/2.0
  return S

def Test_hp2(x1,X,s) :  #test di ipotesi con un valore calcolato
  t = np.absolute(x1-X)/s  #t di confronto
  R = quad(Gaussian,-t,t) #calcolo del rapporto con l'integrale
  S = (1 - R[0])/2.0
  return S

def cov(x,y,sy) :
  t = -1*(np.sum(x)/(len(x)*np.sum(x**2)-(np.sum(x))**2))
  r = t*(np.power(sy,2))
  return r


def minimi_quadrati_senza_A(x,y,sy) :
  f=np.sum(x*y)
  g=np.sum(x**2)
  B=f/g
  sigma_B=sy/np.sqrt(g)
  return B, sigma_B

def chiquadrosenzaA(x, y, B, sy) :
  S=np.sum((np.power(y-B*x,2))/sy**2)
  return S

def Tstudent(x, y, sy) :
  TstudentG = np.sum((x-y)/(sy))
  return TstudentG

def err_pes(sx):
  pi = (sx)**(-2)
  S = np.sqrt(np.sum(pi))
  c = 1/S
  return c
